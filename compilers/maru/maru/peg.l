; defining bootstrap parser
; parsing peg grammar definition
; generating compiled parser
; compiling generated parser
; reparsing grammar definition
; comparing output
; dumping generated parser
(define-class <peg> <parser> (grammar-name))
(define-selector $effect)
(define-selector $value)
(define-selector $findvars)
(define-selector $gen_cola_effect_definition)
(define-selector $gen_cola_value_definition)
(define-selector $gen_cola_effect_definitions)
(define-selector $gen_cola_value_definitions)
(define-selector $gen_cola_effect_declaration)
(define-selector $gen_cola_value_declaration)
(define-selector $gen_cola_effect_declarations)
(define-selector $gen_cola_value_declarations)
(define-selector $gen_cola)
(define-selector $gen_cola_parser)
(define-selector $parser_spec)
(define-selector $varname)
(define-selector $start)
(define-selector $definition)
(define-selector $expression)
(define-selector $sequence)
(define-selector $predicate)
(define-selector $conversion)
(define-selector $repetition)
(define-selector $atom)
(define-selector $llist)
(define-selector $sexpression)
(define-selector $sspace)
(define-selector $scomment)
(define-selector $sexpr)
(define-selector $symbol)
(define-selector $symrest)
(define-selector $symfirst)
(define-selector $grammar)
(define-selector $class)
(define-selector $string)
(define-selector $char)
(define-selector $identifier)
(define-selector $idpart)
(define-selector $letter)
(define-selector $number)
(define-selector $higit)
(define-selector $digit)
(define-selector $dot)
(define-selector $rbrace)
(define-selector $lbrace)
(define-selector $rparen)
(define-selector $lparen)
(define-selector $star)
(define-selector $plus)
(define-selector $minus)
(define-selector $query)
(define-selector $at)
(define-selector $dollar)
(define-selector $dollardbl)
(define-selector $dollarhash)
(define-selector $comma)
(define-selector $commaat)
(define-selector $backquote)
(define-selector $quotesgl)
(define-selector $arrow)
(define-selector $colon)
(define-selector $ampersand)
(define-selector $pling)
(define-selector $bar)
(define-selector $space)
(define-selector $comment)
(define-selector $eol)
(define-selector $blank)
(define-selector $equals)
(define-method $effect <peg> () (let ((op) (r) (obj) (str) (exp) (e) (exps) (type) (args) (name)) (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-rule) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s (let () (set args self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (concat-list (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args) (cons (cons (quote or) (cons (cons (concat-symbol (quote $$) name) (cons (quote self) (quote ()))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ())))) (quote ())))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-rule) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (concat-symbol (quote $$) name) (cons (quote self) (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-rule-in) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set type self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s (let () (set args self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote let) (cons (quote ()) (concat-list (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args) (cons (cons (quote or) (cons (cons (concat-symbol (quote $$) name) (cons (cons (quote parser) (cons (concat-symbol (quote <) (concat-symbol type (quote >))) (cons (quote self.source) (quote ())))) (quote ()))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ())))) (quote ()))))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-rule-in) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set type self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (concat-symbol (quote $$) name) (cons (cons (quote parser) (cons (concat-symbol (quote <) (concat-symbol type (quote >))) (cons (quote self.source) (quote ())))) (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-first) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while ($effect self) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s (let () (set exps self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote or) exps)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-all) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while ($effect self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote or) (cons (cons (quote and) e) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ())))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-zero-one) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($effect self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (quote ()) (cons exp (cons (quote 1) (quote ())))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-zero-more) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($effect self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (quote ()) (cons (cons (quote while) (cons exp (quote ()))) (cons (quote 1) (quote ())))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-one-more) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($effect self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote and) (cons exp (cons (cons (quote let) (cons (quote ()) (cons (cons (quote while) (cons exp (quote ()))) (cons (quote 1) (quote ()))))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote peek-for) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($effect self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (quote ())))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote peek-expr) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result exp) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote peek-not) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($effect self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote not) (cons (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (quote ())))) (quote ())))) (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-list) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($effect self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote and) (cons (cons (quote pair?) (cons (cons (quote parser-stream-peek) (cons (quote self.source) (quote ()))) (quote ()))) (cons (cons (quote let) (cons (cons (cons (quote src) (cons (quote self.source) (quote ()))) (quote ())) (cons (cons (quote set) (cons (quote self.source) (cons (cons (quote parser-stream) (cons (cons (quote list-stream) (cons (cons (quote parser-stream-peek) (cons (quote src) (quote ()))) (quote ()))) (quote ()))) (quote ())))) (cons (cons (quote let) (cons (cons (cons (quote ok) (cons exp (quote ()))) (quote ())) (cons (cons (quote set) (cons (quote self.source) (cons (quote src) (quote ())))) (cons (cons (quote and) (cons (quote ok) (cons (cons (quote parser-stream-next) (cons (quote src) (quote ()))) (quote ())))) (quote ()))))) (quote ()))))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-class) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set str self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote parser-stream-match-class) (cons (quote self.source) (cons (make-class str) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-string) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set str self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote parser-stream-match-string) (cons (quote self.source) (cons str (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-object) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set obj self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote parser-stream-match-object) (cons (quote self.source) (cons (cons (quote quote) (cons obj (quote ()))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-any) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (quote (parser-stream-match-any self.source))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote make-span) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($effect self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result exp) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote make-string) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($effect self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result exp) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote make-symbol) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($effect self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result exp) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote make-number) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set r self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($effect self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result exp) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote assign-result) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($value self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote and) (cons exp (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons name (cons (quote self.result) (quote ())))) (cons (quote 1) (quote ()))))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote result-expr) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (quote ()) (cons exp (cons (quote 1) (quote ())))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set op self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (error "cannot generate value for " op)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result (error "cannot generate value for nil")) 1)))) (set self.source src) (and ok (parser-stream-next src)))))))
(define-method $value <peg> () (let ((op) (r) (obj) (str) (exp) (v) (e) (exps) (type) (args) (name)) (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-rule) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s (let () (set args self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (concat-list (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args) (cons (cons (quote or) (cons (cons (concat-symbol (quote $) name) (cons (quote self) (quote ()))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ())))) (quote ())))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-rule) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (concat-symbol (quote $) name) (cons (quote self) (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-rule-in) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set type self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s (let () (set args self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (cons (cons (quote _p) (cons (cons (quote parser) (cons (concat-symbol (quote <) (concat-symbol type (quote >))) (cons (quote self.source) (quote ())))) (quote ()))) (quote ()))) (concat-list (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args) (cons (cons (quote if) (cons (cons (concat-symbol (quote $) name) (cons (quote _p) (quote ()))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote <parser>-result) (cons (quote _p) (quote ()))) (quote ())))) (cons (quote 1) (quote ()))))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ()))))) (quote ())))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-rule-in) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set type self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (cons (cons (quote _p) (cons (cons (quote parser) (cons (concat-symbol (quote <) (concat-symbol type (quote >))) (cons (quote self.source) (quote ())))) (quote ()))) (quote ())) (cons (cons (quote and) (cons (cons (concat-symbol (quote $) name) (cons (quote _p) (quote ()))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote <parser>-result) (cons (quote _p) (quote ()))) (quote ())))) (cons (quote 1) (quote ()))))) (quote ())))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-first) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while ($value self) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s (let () (set exps self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote or) exps)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-all) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($effect self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($value self))) (and _s (let () (set v self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote or) (cons (cons (quote and) (concat-list e (cons v (quote ())))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ())))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-zero-one) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($value self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (cons (cons (quote _list_) (cons (cons (quote group) (quote ())) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote group-append) (cons (quote _list_) (cons (quote self.result) (quote ())))) (quote ())))) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote group->list!) (cons (quote _list_) (quote ()))) (quote ())))) (cons (quote 1) (quote ()))))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-zero-more) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($value self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (cons (cons (quote _list_) (cons (cons (quote group) (quote ())) (quote ()))) (quote ())) (cons (cons (quote while) (cons exp (cons (cons (quote group-append) (cons (quote _list_) (cons (quote self.result) (quote ())))) (quote ())))) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote group->list!) (cons (quote _list_) (quote ()))) (quote ())))) (cons (quote 1) (quote ()))))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-one-more) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($value self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (cons (cons (quote _list_) (cons (cons (quote group) (quote ())) (quote ()))) (quote ())) (cons (cons (quote while) (cons exp (cons (cons (quote group-append) (cons (quote _list_) (cons (quote self.result) (quote ())))) (quote ())))) (cons (cons (quote and) (cons (cons (quote not) (cons (cons (quote group-empty?) (cons (quote _list_) (quote ()))) (quote ()))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote group->list!) (cons (quote _list_) (quote ()))) (quote ())))) (cons (quote 1) (quote ()))))) (quote ())))) (quote ())))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote peek-for) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($value self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (quote ())))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote peek-expr) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result exp) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote peek-not) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($value self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote not) (cons (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (quote ())))) (quote ())))) (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-list) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($value self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote and) (cons (cons (quote pair?) (cons (cons (quote parser-stream-peek) (cons (quote self.source) (quote ()))) (quote ()))) (cons (cons (quote let) (cons (cons (cons (quote src) (cons (quote self.source) (quote ()))) (quote ())) (cons (cons (quote set) (cons (quote self.source) (cons (cons (quote parser-stream) (cons (cons (quote list-stream) (cons (cons (quote parser-stream-peek) (cons (quote src) (quote ()))) (quote ()))) (quote ()))) (quote ())))) (cons (cons (quote let) (cons (cons (cons (quote ok) (cons exp (quote ()))) (quote ())) (cons (cons (quote set) (cons (quote self.source) (cons (quote src) (quote ())))) (cons (cons (quote and) (cons (quote ok) (cons (cons (quote parser-stream-next) (cons (quote src) (quote ()))) (quote ())))) (quote ()))))) (quote ()))))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-class) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set str self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote set) (cons (quote self.result) (cons (cons (quote parser-stream-match-class) (cons (quote self.source) (cons (make-class str) (quote ())))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-string) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set str self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote set) (cons (quote self.result) (cons (cons (quote parser-stream-match-string) (cons (quote self.source) (cons str (quote ())))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-object) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set obj self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote and) (cons (cons (quote =) (cons (cons (quote quote) (cons obj (quote ()))) (cons (cons (quote parser-stream-peek) (cons (quote self.source) (quote ()))) (quote ())))) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote parser-stream-next) (cons (quote self.source) (quote ()))) (quote ())))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote match-any) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (quote (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote make-span) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($effect self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote list-from-to) (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ())))) (quote ())))) (cons (quote 1) (quote ()))))) (quote ())))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote make-string) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($value self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote and) (cons exp (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote list->string) (cons (quote self.result) (quote ()))) (quote ())))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote make-symbol) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($value self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote and) (cons exp (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote string->symbol) (cons (cons (quote list->string) (cons (quote self.result) (quote ()))) (quote ()))) (quote ())))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote make-number) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set r self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($value self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote and) (cons exp (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote string->number-base) (cons (cons (quote list->string) (cons (quote self.result) (quote ()))) (cons r (quote ())))) (quote ())))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote assign-result) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($value self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote and) (cons exp (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons name (cons (quote self.result) (quote ())))) (cons (quote 1) (quote ()))))) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote result-expr) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (quote self.result) (cons exp (quote ())))) (cons (quote 1) (quote ())))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set op self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (error "cannot generate value for " op)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result (error "cannot generate value for nil")) 1)))) (set self.source src) (and ok (parser-stream-next src)))))))
(define-method $findvars <peg> () (let ((name) (vars)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set vars self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote assign-result) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (let () (parser-stream-push self.source vars) (or ($findvars self) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))) (and _s (let () (set vars self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (if (assq name vars) vars (cons (cons name) vars))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (= (quote result-expr) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result vars) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_list_ (group))) (while (let ((_s (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (let () (parser-stream-push self.source vars) (or ($findvars self) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))) (and _s (let () (set vars self.result) _s))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result vars) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result vars) 1)))) (set self.source src) (and ok (parser-stream-next src))))))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_effect_definition <peg> () (let ((exp) (vars) (id)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set id self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((_s (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (let () (parser-stream-push self.source ()) (or ($findvars self) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))) (and _s (let () (set vars self.result) _s))) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($effect self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))))) (set self.source src) (and ok (parser-stream-next src))))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote define-method) (cons (concat-symbol (quote $$) id) (cons (oop-at (%typecheck <peg> self) 2) (cons (quote ()) (cons (cons (quote let) (cons vars (cons exp (quote ())))) (quote ()))))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_value_definition <peg> () (let ((exp) (vars) (id)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set id self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((_s (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (let () (parser-stream-push self.source ()) (or ($findvars self) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))) (and _s (let () (set vars self.result) _s))) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($value self))) (and _s (let () (set exp self.result) _s))))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))))) (set self.source src) (and ok (parser-stream-next src))))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote define-method) (cons (concat-symbol (quote $) id) (cons (oop-at (%typecheck <peg> self) 2) (cons (quote ()) (cons (cons (quote let) (cons vars (cons exp (quote ())))) (quote ()))))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_effect_definitions <peg> () (let ((d)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((_s (let ((_list_ (group))) (while ($gen_cola_effect_definition self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set d self.result) _s))))) (set self.source src) (and ok (parser-stream-next src))))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result d) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_value_definitions <peg> () (let ((d)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((_s (let ((_list_ (group))) (while ($gen_cola_value_definition self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set d self.result) _s))))) (set self.source src) (and ok (parser-stream-next src))))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result d) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_effect_declaration <peg> () (let ((id)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set id self.result) _s))))) (set self.source src) (and ok (parser-stream-next src))))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote define-selector) (cons (concat-symbol (quote $$) id) (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_value_declaration <peg> () (let ((id)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set id self.result) _s))))) (set self.source src) (and ok (parser-stream-next src))))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote define-selector) (cons (concat-symbol (quote $) id) (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_effect_declarations <peg> () (let ((d)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((_s (let ((_list_ (group))) (while ($gen_cola_effect_declaration self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set d self.result) _s))))) (set self.source src) (and ok (parser-stream-next src))))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result d) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_value_declarations <peg> () (let ((d)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((_s (let ((_list_ (group))) (while ($gen_cola_value_declaration self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set d self.result) _s))))) (set self.source src) (and ok (parser-stream-next src))))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result d) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola <peg> () (let ((d) (c) (b) (a)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((_s ($gen_cola_value_declarations self))) (and _s (let () (set a self.result) _s))) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((_s ($gen_cola_effect_declarations self))) (and _s (let () (set b self.result) _s))) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((_s ($gen_cola_value_definitions self))) (and _s (let () (set c self.result) _s))) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($gen_cola_effect_definitions self))) (and _s (let () (set d self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (concat-list a (concat-list b (concat-list c d)))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_parser <peg> () (let ((definitions) (vars) (parent) (name)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set parent self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set vars self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set definitions self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (set-oop-at (%typecheck <peg> self) 2 name)) 1))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (let () (parser-stream-push self.source definitions) (or ($gen_cola self) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))) (and _s (let () (set definitions self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (cons (quote define-class) (cons name (cons parent (cons vars (quote ()))))) definitions)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $parser_spec <peg> () (let ((definitions) (vars) (parent) (name)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s ($varname self))) (and _s (let () (set name self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($colon self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($varname self))) (and _s (let () (set parent self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($lparen self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while ($varname self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set vars self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($rparen self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while ($definition self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set definitions self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (or (not (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos)))) (let () (set self.result (error "error in grammar near: " (parser-stream-context self.source))) 1)))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (let () (parser-stream-push self.source definitions) (parser-stream-push self.source vars) (parser-stream-push self.source parent) (parser-stream-push self.source name) (or ($gen_cola_parser self) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))))))))))))))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $varname <peg> () (let ((s)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s ($symbol self))) (and _s (let () (set s self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result s) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $start <peg> () (let ((result)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (or ($parser_spec self) (let ((_list_ (group))) (while ($definition self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1)))) (and _s (let () (set result self.result) _s))))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $definition <peg> () (let ((e) (id)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($identifier self))) (and _s (let () (set id self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($equals self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($expression self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (set self.result (parser-stream-match-string self.source ";")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons id (cons e (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $expression <peg> () (let ((t) (s)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s ($sequence self))) (and _s (let () (set s self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($bar self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($sequence self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s (let () (set t self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote match-first) (cons s t))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result s) 1)))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $sequence <peg> () (let ((q) (p)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s ($predicate self))) (and _s (let () (set p self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while ($predicate self) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s (let () (set q self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote match-all) (cons p q))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result p) 1)))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $predicate <peg> () (let ((e)) (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($pling self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($conversion self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote peek-not) (cons e (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($ampersand self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($arrow self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($sexpression self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote peek-expr) (cons e (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s ($conversion self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote peek-for) (cons e (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) ($conversion self))))
(define-method $conversion <peg> () (let ((i) (n) (e)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s ($repetition self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_list_ (group))) (while (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($at self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let () (set self.result (cons (quote make-span) (cons e (quote ())))) 1))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($dollarhash self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s ($number self))) (and _s (let () (set n self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let () (set self.result (cons (quote make-number) (cons n (cons e (quote ()))))) 1))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((_s (let () (set self.result (cons (quote make-number) (cons (quote 10) (cons e (quote ()))))) 1))) (and _s (let () (set e self.result) _s)))))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($dollardbl self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let () (set self.result (cons (quote make-symbol) (cons e (quote ())))) 1))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($dollar self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let () (set self.result (cons (quote make-string) (cons e (quote ())))) 1))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($colon self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($identifier self))) (and _s (let () (set i self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let () (set self.result (cons (quote assign-result) (cons i (cons e (quote ()))))) 1))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result e) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $repetition <peg> () (let ((e)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s ($atom self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_list_ (group))) (and (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($query self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let () (set self.result (cons (quote match-zero-one) (cons e (quote ())))) 1))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($star self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let () (set self.result (cons (quote match-zero-more) (cons e (quote ())))) 1))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($plus self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let () (set self.result (cons (quote match-one-more) (cons e (quote ())))) 1))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result e) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $atom <peg> () (let ((p) (e)) (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($lparen self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($expression self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($rparen self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result e) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($quotesgl self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($sexpression self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote match-object) (cons e (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s ($string self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote match-string) (cons e (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s ($class self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote match-class) (cons e (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s ($idpart self))) (and _s (let () (set p self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (set self.result (parser-stream-match-string self.source "-")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($identifier self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote match-rule-in) (cons p (cons e (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s ($identifier self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote match-rule) (cons e (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($lbrace self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while ($sexpression self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($rbrace self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote match-rule) e)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($dot self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote match-any) (quote ()))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($arrow self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($sexpression self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote result-expr) (cons e (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($backquote self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($llist self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote match-list) (cons e (quote ())))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))))))
(define-method $llist <peg> () (let ((e)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($lparen self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($expression self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($rparen self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result e) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $sexpression <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($sspace self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($sexpr self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $sspace <peg> () (let () (let ((_list_ (group))) (while (or ($blank self) ($eol self) ($scomment self)) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1)))
(define-method $scomment <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source ";")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (not (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and ($eol self) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos)))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $sexpr <peg> () (let ((f) (e)) (or (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_list_ (group))) (and (set self.result (parser-stream-match-string self.source "-")) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_list_ (group))) (while ($digit self) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result (list-from-to pos (oop-at (%typecheck <parser-stream> self.source) 1))) 1))) (set self.result (string->number-base (list->string self.result) 10))) ($symbol self) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "?")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "\"")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (not (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (set self.result (parser-stream-match-string self.source "\"")) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos)))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($char self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1) (set self.result (list->string self.result))))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (set self.result (parser-stream-match-string self.source "\"")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result e) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "(")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while ($sexpression self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_list_ (group))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($dot self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($sexpression self))) (and _s (let () (set f self.result) _s))))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($sspace self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (set self.result (parser-stream-match-string self.source ")")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (set-list-source (concat-list e f) e)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "'")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($sexpression self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (list (quote quote) e)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "`")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($sexpression self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (list (quote quasiquote) e)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source ",@")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($sexpression self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (list (quote unquote-splicing) e)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source ",")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($sexpression self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (list (quote unquote) e)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "{")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($grammar self))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "}")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result e) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result (error "error in grammar near: " (parser-stream-context self.source))) 1)))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source ";")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (not (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (set self.result (parser-stream-match-class self.source "\012\015")) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos)))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))))))
(define-method $symbol <peg> () (let () (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($symfirst self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_list_ (group))) (while ($symrest self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result (list-from-to pos (oop-at (%typecheck <parser-stream> self.source) 1))) 1))) (set self.result (string->symbol (list->string self.result))))))
(define-method $symrest <peg> () (let () (set self.result (parser-stream-match-class self.source "!#$%&*+-./0123456789:<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ^_abcdefghijklmnopqrstuvwxyz|~"))))
(define-method $symfirst <peg> () (let () (set self.result (parser-stream-match-class self.source "!#$%&*+-/:<=>@ABCDEFGHIJKLMNOPQRSTUVWXYZ^_abcdefghijklmnopqrstuvwxyz|~"))))
(define-method $grammar <peg> () (let ((e) (d) (fields) (parent) (rules) (name)) (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s ($symbol self))) (and _s (let () (set name self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($plus self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while ($definition self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set rules self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote grammar-extend) (cons name rules))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s ($symbol self))) (and _s (let () (set name self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($colon self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s ($symbol self))) (and _s (let () (set parent self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_list_ (group))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($lparen self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while ($identifier self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set fields self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($rparen self))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while ($definition self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set rules self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote grammar-define) (cons name (cons parent (cons fields rules))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))))))))))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s (let ((_list_ (group))) (while ($definition self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set d self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (let ((_list_ (group))) (and ($expression self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set e self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result (cons (quote grammar-eval) (cons d (cons (car e) (quote ()))))) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))))))
(define-method $class <peg> () (let ((s)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "[")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (not (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (set self.result (parser-stream-match-string self.source "]")) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos)))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($char self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1) (set self.result (list->string self.result))))) (and _s (let () (set s self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (set self.result (parser-stream-match-string self.source "]")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result s) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $string <peg> () (let ((s)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "\"")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_s (and (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (not (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (set self.result (parser-stream-match-string self.source "\"")) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos)))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($char self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1) (set self.result (list->string self.result))))) (and _s (let () (set s self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (set self.result (parser-stream-match-string self.source "\"")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result s) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $char <peg> () (let () (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "\\")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "t")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result 9) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "n")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result 10) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "r")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result 13) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "x")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($higit self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($higit self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result (list-from-to pos (oop-at (%typecheck <parser-stream> self.source) 1))) 1))) (set self.result (string->number-base (list->string self.result) 16))))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "u")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($higit self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($higit self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($higit self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($higit self))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result (list-from-to pos (oop-at (%typecheck <parser-stream> self.source) 1))) 1))) (set self.result (string->number-base (list->string self.result) 16))))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1))))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))))
(define-method $identifier <peg> () (let ((id)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s ($idpart self))) (and _s (let () (set id self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result id) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $idpart <peg> () (let () (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ ($letter self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_list_ (group))) (while (or ($letter self) ($digit self)) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result (list-from-to pos (oop-at (%typecheck <parser-stream> self.source) 1))) 1))) (set self.result (string->symbol (list->string self.result))))))
(define-method $letter <peg> () (let () (set self.result (parser-stream-match-class self.source "ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"))))
(define-method $number <peg> () (let ((n)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_s (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (let ((_list_ (group))) (and (set self.result (parser-stream-match-string self.source "-")) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_list_ (group))) (while ($digit self) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result (list-from-to pos (oop-at (%typecheck <parser-stream> self.source) 1))) 1))) (set self.result (string->number-base (list->string self.result) 10))))) (and _s (let () (set n self.result) _s))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let () (set self.result n) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $higit <peg> () (let () (set self.result (parser-stream-match-class self.source "0123456789ABCDEFabcdef"))))
(define-method $digit <peg> () (let () (set self.result (parser-stream-match-class self.source "0123456789"))))
(define-method $dot <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source ".")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $rbrace <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "}")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $lbrace <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "{")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $rparen <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source ")")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $lparen <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "(")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $star <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "*")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $plus <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "+")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $minus <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "-")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $query <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "?")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $at <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "@")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $dollar <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "$")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $dollardbl <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "$$")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $dollarhash <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "$#")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $comma <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source ",")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $commaat <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source ",@")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $backquote <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "`")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $quotesgl <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "'")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $arrow <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "->")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $colon <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source ":")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $ampersand <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "&")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $pling <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "!")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $bar <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "|")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $space <peg> () (let () (let ((_list_ (group))) (while (or ($blank self) ($eol self) ($comment self)) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1)))
(define-method $comment <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "#")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (not (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and ($eol self) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos)))))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $eol <peg> () (let () (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "\012")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_list_ (group))) (while (set self.result (parser-stream-match-string self.source "\015")) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "\015")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ (let ((_list_ (group))) (while (set self.result (parser-stream-match-string self.source "\012")) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))))))
(define-method $blank <peg> () (let () (set self.result (parser-stream-match-class self.source "\011 "))))
(define-method $equals <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s_ (set self.result (parser-stream-match-string self.source "=")))) (and _s_ (or (= _s_ *recurred*) (and (let ((_s_ ($space self))) (and _s_ (or (= _s_ *recurred*) 1)))))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
; parser bootstrap complete
; WARNING: unreachable from start: commaat
; WARNING: unreachable from start: comma
; WARNING: unreachable from start: minus
