; defining bootstrap parser
; parsing peg grammar definition
; generating compiled parser
; compiling generated parser
; reparsing grammar definition
; comparing output
; dumping generated parser
(define-class <peg> <parser> (grammar-name))
(define-selector $effect)
(define-selector $value)
(define-selector $findvars)
(define-selector $gen_cola_effect_definition)
(define-selector $gen_cola_value_definition)
(define-selector $gen_cola_effect_definitions)
(define-selector $gen_cola_value_definitions)
(define-selector $gen_cola_effect_declaration)
(define-selector $gen_cola_value_declaration)
(define-selector $gen_cola_effect_declarations)
(define-selector $gen_cola_value_declarations)
(define-selector $gen_cola)
(define-selector $gen_cola_parser)
(define-selector $parser_spec)
(define-selector $parser_class)
(define-selector $parser_decl)
(define-selector $varname)
(define-selector $start)
(define-selector $definitions)
(define-selector $definition)
(define-selector $parameters)
(define-selector $expression)
(define-selector $sequence)
(define-selector $predicate)
(define-selector $conversion)
(define-selector $repetition)
(define-selector $atom)
(define-selector $llist)
(define-selector $sexpression)
(define-selector $sspace)
(define-selector $scomment)
(define-selector $sexpr)
(define-selector $sinteger)
(define-selector $symbol)
(define-selector $symrest)
(define-selector $symfirst)
(define-selector $grammar)
(define-selector $class)
(define-selector $string)
(define-selector $char)
(define-selector $identifier)
(define-selector $idpart)
(define-selector $letter)
(define-selector $number)
(define-selector $higit)
(define-selector $digit)
(define-selector $dot)
(define-selector $rbrace)
(define-selector $lbrace)
(define-selector $rparen)
(define-selector $lparen)
(define-selector $star)
(define-selector $plus)
(define-selector $minus)
(define-selector $query)
(define-selector $at)
(define-selector $dollar)
(define-selector $dollardbl)
(define-selector $dollarhash)
(define-selector $comma)
(define-selector $commaat)
(define-selector $backquote)
(define-selector $quotesgl)
(define-selector $arrow)
(define-selector $colon)
(define-selector $ampersand)
(define-selector $pling)
(define-selector $bar)
(define-selector $space)
(define-selector $comment)
(define-selector $eol)
(define-selector $blank)
(define-selector $equals)
(define-method $effect <peg> () (let ((op) (r) (obj) (str) (exp) (e) (exps) (type) (args) (name)) (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-rule) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))) (let ((_s (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s (let () (set args self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (concat-list (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args) (cons (cons (quote or) (cons (cons (quote peg-match-rule) (cons (concat-symbol (quote $$) name) (cons (quote self) (quote ())))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ())))) (quote ())))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-rule) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote peg-match-rule) (cons (concat-symbol (quote $$) name) (cons (quote self) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-rule-in) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set type self.result) _s))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))) (let ((_s (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s (let () (set args self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote let) (cons (quote ()) (concat-list (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args) (cons (cons (quote or) (cons (cons (quote peg-match-rule) (cons (concat-symbol (quote $$) name) (cons (cons (quote parser) (cons (concat-symbol (quote <) (concat-symbol type (quote >))) (cons (quote self.source) (quote ())))) (quote ())))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ())))) (quote ()))))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-rule-in) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set type self.result) _s))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote peg-match-rule) (cons (concat-symbol (quote $$) name) (cons (cons (quote parser) (cons (concat-symbol (quote <) (concat-symbol type (quote >))) (cons (quote self.source) (quote ())))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-first) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $effect (quote $effect) self) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s (let () (set exps self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote or) exps)) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-all) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $effect (quote $effect) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set e self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote or) (cons (cons (quote and) e) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ())))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-zero-one) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $effect (quote $effect) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (quote ()) (cons exp (cons (quote 1) (quote ())))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-zero-more) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $effect (quote $effect) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (quote ()) (cons (cons (quote while) (cons exp (quote ()))) (cons (quote 1) (quote ())))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-one-more) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $effect (quote $effect) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote and) (cons exp (cons (cons (quote let) (cons (quote ()) (cons (cons (quote while) (cons exp (quote ()))) (cons (quote 1) (quote ()))))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote peek-for) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $effect (quote $effect) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (quote ())))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote peek-expr) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result exp) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote peek-not) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $effect (quote $effect) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote not) (cons (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (quote ())))) (quote ())))) (quote ())))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-list) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $effect (quote $effect) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote and) (cons (cons (quote pair?) (cons (cons (quote parser-stream-peek) (cons (quote self.source) (quote ()))) (quote ()))) (cons (cons (quote let) (cons (cons (cons (quote src) (cons (quote self.source) (quote ()))) (quote ())) (cons (cons (quote set) (cons (quote self.source) (cons (cons (quote parser-stream) (cons (cons (quote list-stream) (cons (cons (quote parser-stream-peek) (cons (quote src) (quote ()))) (quote ()))) (quote ()))) (quote ())))) (cons (cons (quote let) (cons (cons (cons (quote ok) (cons exp (quote ()))) (quote ())) (cons (cons (quote set) (cons (quote self.source) (cons (quote src) (quote ())))) (cons (cons (quote and) (cons (quote ok) (cons (cons (quote parser-stream-next) (cons (quote src) (quote ()))) (quote ())))) (quote ()))))) (quote ()))))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-class) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set str self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote parser-stream-match-class) (cons (quote self.source) (cons (make-class str) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-string) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set str self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote parser-stream-match-string) (cons (quote self.source) (cons str (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-object) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set obj self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote parser-stream-match-object) (cons (quote self.source) (cons (cons (quote quote) (cons obj (quote ()))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-any) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let () (peg-source-range-begin self) (set self.result (quote (parser-stream-match-any self.source))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote make-span) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $effect (quote $effect) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result exp) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote make-string) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $effect (quote $effect) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result exp) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote make-symbol) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $effect (quote $effect) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result exp) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote make-number) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set r self.result) _s))) (let ((_s (peg-invoke-rule $effect (quote $effect) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result exp) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote assign-result) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))) (let ((_s (peg-invoke-rule $value (quote $value) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote and) (cons exp (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons name (cons (quote self.result) (quote ())))) (cons (quote 1) (quote ()))))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote result-expr) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (quote ()) (cons (cons (quote peg-source-range-begin) (cons (quote self) (quote ()))) (cons exp (cons (cons (quote peg-source-range-end) (cons (quote self) (quote ()))) (cons (quote 1) (quote ())))))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set op self.result) _s))) (let () (peg-source-range-begin self) (set self.result (error "cannot generate value for " op)) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (peg-source-range-begin self) (set self.result (error "cannot generate value for nil")) (peg-source-range-end self) 1)))) (set self.source src) (and ok (parser-stream-next src)))))))
(define-method $value <peg> () (let ((op) (r) (obj) (str) (exp) (v) (e) (exps) (type) (args) (name)) (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-rule) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))) (let ((_s (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s (let () (set args self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (concat-list (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args) (cons (cons (quote or) (cons (cons (quote peg-match-rule) (cons (concat-symbol (quote $) name) (cons (quote self) (quote ())))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ())))) (quote ())))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-rule) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote peg-match-rule) (cons (concat-symbol (quote $) name) (cons (quote self) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-rule-in) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set type self.result) _s))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))) (let ((_s (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s (let () (set args self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (cons (cons (quote _p) (cons (cons (quote parser) (cons (concat-symbol (quote <) (concat-symbol type (quote >))) (cons (quote self.source) (quote ())))) (quote ()))) (quote ()))) (concat-list (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args) (cons (cons (quote if) (cons (cons (quote peg-match-rule) (cons (concat-symbol (quote $) name) (cons (quote _p) (quote ())))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote <parser>-result) (cons (quote _p) (quote ()))) (quote ())))) (cons (quote 1) (quote ()))))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ()))))) (quote ())))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-rule-in) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set type self.result) _s))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (cons (cons (quote _p) (cons (cons (quote parser) (cons (concat-symbol (quote <) (concat-symbol type (quote >))) (cons (quote self.source) (quote ())))) (quote ()))) (quote ())) (cons (cons (quote and) (cons (cons (quote peg-match-rule) (cons (concat-symbol (quote $) name) (cons (quote _p) (quote ())))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote <parser>-result) (cons (quote _p) (quote ()))) (quote ())))) (cons (quote 1) (quote ()))))) (quote ())))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-first) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $value (quote $value) self) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s (let () (set exps self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote or) exps)) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-all) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos))) (peg-invoke-rule $effect (quote $effect) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set e self.result) _s))) (let ((_s (peg-invoke-rule $value (quote $value) self))) (and _s (let () (set v self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote or) (cons (cons (quote and) (concat-list e (cons v (quote ())))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ())))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-zero-one) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $value (quote $value) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (cons (cons (quote _list_) (cons (cons (quote group) (quote ())) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote group-append) (cons (quote _list_) (cons (quote self.result) (quote ())))) (quote ())))) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote group->list!) (cons (quote _list_) (quote ()))) (quote ())))) (cons (quote 1) (quote ()))))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-zero-more) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $value (quote $value) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (cons (cons (quote _list_) (cons (cons (quote group) (quote ())) (quote ()))) (quote ())) (cons (cons (quote while) (cons exp (cons (cons (quote group-append) (cons (quote _list_) (cons (quote self.result) (quote ())))) (quote ())))) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote group->list!) (cons (quote _list_) (quote ()))) (quote ())))) (cons (quote 1) (quote ()))))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-one-more) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $value (quote $value) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (cons (cons (quote _list_) (cons (cons (quote group) (quote ())) (quote ()))) (quote ())) (cons (cons (quote while) (cons exp (cons (cons (quote group-append) (cons (quote _list_) (cons (quote self.result) (quote ())))) (quote ())))) (cons (cons (quote and) (cons (cons (quote not) (cons (cons (quote group-empty?) (cons (quote _list_) (quote ()))) (quote ()))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote group->list!) (cons (quote _list_) (quote ()))) (quote ())))) (cons (quote 1) (quote ()))))) (quote ())))) (quote ())))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote peek-for) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $value (quote $value) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (quote ())))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote peek-expr) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result exp) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote peek-not) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $value (quote $value) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote not) (cons (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (quote ())))) (quote ())))) (quote ())))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-list) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $value (quote $value) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote and) (cons (cons (quote pair?) (cons (cons (quote parser-stream-peek) (cons (quote self.source) (quote ()))) (quote ()))) (cons (cons (quote let) (cons (cons (cons (quote src) (cons (quote self.source) (quote ()))) (quote ())) (cons (cons (quote set) (cons (quote self.source) (cons (cons (quote parser-stream) (cons (cons (quote list-stream) (cons (cons (quote parser-stream-peek) (cons (quote src) (quote ()))) (quote ()))) (quote ()))) (quote ())))) (cons (cons (quote let) (cons (cons (cons (quote ok) (cons exp (quote ()))) (quote ())) (cons (cons (quote set) (cons (quote self.source) (cons (quote src) (quote ())))) (cons (cons (quote and) (cons (quote ok) (cons (cons (quote parser-stream-next) (cons (quote src) (quote ()))) (quote ())))) (quote ()))))) (quote ()))))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-class) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set str self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote set) (cons (quote self.result) (cons (cons (quote parser-stream-match-class) (cons (quote self.source) (cons (make-class str) (quote ())))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-string) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set str self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote set) (cons (quote self.result) (cons (cons (quote parser-stream-match-string) (cons (quote self.source) (cons str (quote ())))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-object) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set obj self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote and) (cons (cons (quote =) (cons (cons (quote quote) (cons obj (quote ()))) (cons (cons (quote parser-stream-peek) (cons (quote self.source) (quote ()))) (quote ())))) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote parser-stream-next) (cons (quote self.source) (quote ()))) (quote ())))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote match-any) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let () (peg-source-range-begin self) (set self.result (quote (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote make-span) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $effect (quote $effect) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote list-from-to) (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ())))) (quote ())))) (cons (quote 1) (quote ()))))) (quote ())))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote make-string) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $value (quote $value) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote and) (cons exp (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote list->string) (cons (quote self.result) (quote ()))) (quote ())))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote make-symbol) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (peg-invoke-rule $value (quote $value) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote and) (cons exp (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote string->symbol) (cons (cons (quote list->string) (cons (quote self.result) (quote ()))) (quote ()))) (quote ())))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote make-number) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set r self.result) _s))) (let ((_s (peg-invoke-rule $value (quote $value) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote and) (cons exp (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote string->number-base) (cons (cons (quote list->string) (cons (quote self.result) (quote ()))) (cons r (quote ())))) (quote ())))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote assign-result) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))) (let ((_s (peg-invoke-rule $value (quote $value) self))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote and) (cons exp (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons name (cons (quote self.result) (quote ())))) (cons (quote 1) (quote ()))))) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote result-expr) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set exp self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote let) (cons (quote ()) (cons (cons (quote peg-source-range-begin) (cons (quote self) (quote ()))) (cons (cons (quote set) (cons (quote self.result) (cons exp (quote ())))) (cons (cons (quote peg-source-range-end) (cons (quote self) (quote ()))) (cons (quote 1) (quote ())))))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set op self.result) _s))) (let () (peg-source-range-begin self) (set self.result (error "cannot generate value for " op)) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (peg-source-range-begin self) (set self.result (error "cannot generate value for nil")) (peg-source-range-end self) 1)))) (set self.source src) (and ok (parser-stream-next src)))))))
(define-method $findvars <peg> () (let ((name) (vars)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set vars self.result) _s))) (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote assign-result) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))) (let ((_s (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (let () (parser-stream-push self.source vars) (or (peg-invoke-rule $findvars (quote $findvars) self) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))) (and _s (let () (set vars self.result) _s))) (let () (peg-source-range-begin self) (set self.result (if (assq name vars) vars (cons (cons name) vars))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (= (quote result-expr) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let () (peg-source-range-begin self) (set self.result vars) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (let ((_list_ (group))) (while (let ((_s (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (let () (parser-stream-push self.source vars) (or (peg-invoke-rule $findvars (quote $findvars) self) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))) (and _s (let () (set vars self.result) _s))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1) (let () (peg-source-range-begin self) (set self.result vars) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (peg-source-range-begin self) (set self.result vars) (peg-source-range-end self) 1)))) (set self.source src) (and ok (parser-stream-next src)))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_effect_definition <peg> () (let ((exp) (vars) (id)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set id self.result) _s))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((_s (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (let () (parser-stream-push self.source ()) (or (peg-invoke-rule $findvars (quote $findvars) self) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))) (and _s (let () (set vars self.result) _s))) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos))) (let ((_s (peg-invoke-rule $effect (quote $effect) self))) (and _s (let () (set exp self.result) _s)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))))) (set self.source src) (and ok (parser-stream-next src))))) (let () (peg-source-range-begin self) (set self.result (cons (quote peg-define-rule) (cons (concat-symbol (quote $$) id) (cons (oop-at (%typecheck <peg> self) 3) (cons vars (cons exp (quote ()))))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_value_definition <peg> () (let ((exp) (vars) (id)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set id self.result) _s))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((_s (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (let () (parser-stream-push self.source ()) (or (peg-invoke-rule $findvars (quote $findvars) self) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))) (and _s (let () (set vars self.result) _s))) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos))) (let ((_s (peg-invoke-rule $value (quote $value) self))) (and _s (let () (set exp self.result) _s)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))))) (set self.source src) (and ok (parser-stream-next src))))) (let () (peg-source-range-begin self) (set self.result (cons (quote peg-define-rule) (cons (concat-symbol (quote $) id) (cons (oop-at (%typecheck <peg> self) 3) (cons vars (cons exp (quote ()))))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_effect_definitions <peg> () (let ((d)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $gen_cola_effect_definition (quote $gen_cola_effect_definition) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set d self.result) _s))))) (set self.source src) (and ok (parser-stream-next src))))) (let () (peg-source-range-begin self) (set self.result d) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_value_definitions <peg> () (let ((d)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $gen_cola_value_definition (quote $gen_cola_value_definition) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set d self.result) _s))))) (set self.source src) (and ok (parser-stream-next src))))) (let () (peg-source-range-begin self) (set self.result d) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_effect_declaration <peg> () (let ((id)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set id self.result) _s))))) (set self.source src) (and ok (parser-stream-next src))))) (let () (peg-source-range-begin self) (set self.result (cons (quote define-selector) (cons (concat-symbol (quote $$) id) (quote ())))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_value_declaration <peg> () (let ((id)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set id self.result) _s))))) (set self.source src) (and ok (parser-stream-next src))))) (let () (peg-source-range-begin self) (set self.result (cons (quote define-selector) (cons (concat-symbol (quote $) id) (quote ())))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_effect_declarations <peg> () (let ((d)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $gen_cola_effect_declaration (quote $gen_cola_effect_declaration) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set d self.result) _s))))) (set self.source src) (and ok (parser-stream-next src))))) (let () (peg-source-range-begin self) (set self.result d) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_value_declarations <peg> () (let ((d)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $gen_cola_value_declaration (quote $gen_cola_value_declaration) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set d self.result) _s))))) (set self.source src) (and ok (parser-stream-next src))))) (let () (peg-source-range-begin self) (set self.result d) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola <peg> () (let ((d) (c) (b) (a)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((_s (peg-invoke-rule $gen_cola_value_declarations (quote $gen_cola_value_declarations) self))) (and _s (let () (set a self.result) _s))) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((_s (peg-invoke-rule $gen_cola_effect_declarations (quote $gen_cola_effect_declarations) self))) (and _s (let () (set b self.result) _s))) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((_s (peg-invoke-rule $gen_cola_value_definitions (quote $gen_cola_value_definitions) self))) (and _s (let () (set c self.result) _s))) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos))) (let ((_s (peg-invoke-rule $gen_cola_effect_definitions (quote $gen_cola_effect_definitions) self))) (and _s (let () (set d self.result) _s))) (let () (peg-source-range-begin self) (set self.result (concat-list a (concat-list b (concat-list c d)))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $gen_cola_parser <peg> () (let ((definitions) (vars) (parent) (name)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set name self.result) _s))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set parent self.result) _s))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set vars self.result) _s))) (let ((_s (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (and _s (let () (set definitions self.result) _s))) (let () (peg-source-range-begin self) (set self.result (set-oop-at (%typecheck <peg> self) 3 name)) (peg-source-range-end self) 1) (let ((_s (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (let () (parser-stream-push self.source definitions) (or (peg-invoke-rule $gen_cola (quote $gen_cola) self) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))) (and _s (let () (set definitions self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (cons (quote define-class) (cons name (cons parent (cons vars (quote ()))))) definitions)) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $parser_spec <peg> () (let ((defns) (decl)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (let ((_list_ (group))) (and (peg-invoke-rule $parser_decl (quote $parser_decl) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set decl self.result) _s))) (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $definition (quote $definition) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set defns self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons decl defns)) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $parser_class <peg> () (let ((definitions) (decl)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (peg-invoke-rule $parser_decl (quote $parser_decl) self))) (and _s (let () (set decl self.result) _s))) (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $definition (quote $definition) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set definitions self.result) _s))) (peg-invoke-rule $space (quote $space) self) (or (not (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos)))) (let () (peg-source-range-begin self) (set self.result (error "error in grammar near: " (parser-stream-context self.source))) (peg-source-range-end self) 1)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (let () (parser-stream-push self.source definitions) (parser-stream-push self.source (caddr decl)) (parser-stream-push self.source (cadr decl)) (parser-stream-push self.source (car decl)) (or (peg-invoke-rule $gen_cola_parser (quote $gen_cola_parser) self) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $parser_decl <peg> () (let ((vars) (parent) (name)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $space (quote $space) self) (let ((_s (peg-invoke-rule $varname (quote $varname) self))) (and _s (let () (set name self.result) _s))) (peg-invoke-rule $colon (quote $colon) self) (let ((_s (peg-invoke-rule $varname (quote $varname) self))) (and _s (let () (set parent self.result) _s))) (peg-invoke-rule $lparen (quote $lparen) self) (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $varname (quote $varname) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set vars self.result) _s))) (peg-invoke-rule $rparen (quote $rparen) self) (let () (peg-source-range-begin self) (set self.result (cons name (cons parent (cons vars (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $varname <peg> () (let ((s)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (peg-invoke-rule $symbol (quote $symbol) self))) (and _s (let () (set s self.result) _s))) (peg-invoke-rule $space (quote $space) self) (let () (peg-source-range-begin self) (set self.result s) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $start <peg> () (let ((result)) (let ((_s (or (peg-invoke-rule $parser_class (quote $parser_class) self) (peg-invoke-rule $definitions (quote $definitions) self)))) (and _s (let () (set result self.result) _s)))))
(define-method $definitions <peg> () (let () (let ((_list_ (group))) (while (peg-invoke-rule $definition (quote $definition) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1)))
(define-method $definition <peg> () (let ((e) (p) (id)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $space (quote $space) self) (let ((_s (peg-invoke-rule $identifier (quote $identifier) self))) (and _s (let () (set id self.result) _s))) (let ((_s (peg-invoke-rule $parameters (quote $parameters) self))) (and _s (let () (set p self.result) _s))) (peg-invoke-rule $equals (quote $equals) self) (let ((_s (peg-invoke-rule $expression (quote $expression) self))) (and _s (let () (set e self.result) _s))) (set self.result (parser-stream-match-string self.source ";")) (let () (peg-source-range-begin self) (set self.result (cons id (cons e (cons p (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $parameters <peg> () (let () (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $colon (quote $colon) self) (peg-invoke-rule $identifier (quote $identifier) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1)))
(define-method $expression <peg> () (let ((t) (s)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (peg-invoke-rule $sequence (quote $sequence) self))) (and _s (let () (set s self.result) _s))) (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $bar (quote $bar) self) (peg-invoke-rule $sequence (quote $sequence) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s (let () (set t self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote match-first) (cons s t))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (peg-source-range-begin self) (set self.result s) (peg-source-range-end self) 1))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $sequence <peg> () (let ((q) (p)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (peg-invoke-rule $predicate (quote $predicate) self))) (and _s (let () (set p self.result) _s))) (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $predicate (quote $predicate) self) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))))) (and _s (let () (set q self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote match-all) (cons p q))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (peg-source-range-begin self) (set self.result p) (peg-source-range-end self) 1))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $predicate <peg> () (let ((e)) (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $pling (quote $pling) self) (let ((_s (peg-invoke-rule $conversion (quote $conversion) self))) (and _s (let () (set e self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote peek-not) (cons e (quote ())))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $ampersand (quote $ampersand) self) (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $arrow (quote $arrow) self) (let ((_s (peg-invoke-rule $sexpression (quote $sexpression) self))) (and _s (let () (set e self.result) _s))) (peg-invoke-rule $space (quote $space) self) (let () (peg-source-range-begin self) (set self.result (cons (quote peek-expr) (cons e (quote ())))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (peg-invoke-rule $conversion (quote $conversion) self))) (and _s (let () (set e self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote peek-for) (cons e (quote ())))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (peg-invoke-rule $conversion (quote $conversion) self))))
(define-method $conversion <peg> () (let ((i) (n) (e)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (peg-invoke-rule $repetition (quote $repetition) self))) (and _s (let () (set e self.result) _s))) (let ((_list_ (group))) (while (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $at (quote $at) self) (let ((_s (let () (peg-source-range-begin self) (set self.result (cons (quote make-span) (cons e (quote ())))) (peg-source-range-end self) 1))) (and _s (let () (set e self.result) _s)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $dollarhash (quote $dollarhash) self) (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (peg-invoke-rule $number (quote $number) self))) (and _s (let () (set n self.result) _s))) (let ((_s (let () (peg-source-range-begin self) (set self.result (cons (quote make-number) (cons n (cons e (quote ()))))) (peg-source-range-end self) 1))) (and _s (let () (set e self.result) _s)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((_s (let () (peg-source-range-begin self) (set self.result (cons (quote make-number) (cons (quote 10) (cons e (quote ()))))) (peg-source-range-end self) 1))) (and _s (let () (set e self.result) _s))))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $dollardbl (quote $dollardbl) self) (let ((_s (let () (peg-source-range-begin self) (set self.result (cons (quote make-symbol) (cons e (quote ())))) (peg-source-range-end self) 1))) (and _s (let () (set e self.result) _s)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $dollar (quote $dollar) self) (let ((_s (let () (peg-source-range-begin self) (set self.result (cons (quote make-string) (cons e (quote ())))) (peg-source-range-end self) 1))) (and _s (let () (set e self.result) _s)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $colon (quote $colon) self) (let ((_s (peg-invoke-rule $identifier (quote $identifier) self))) (and _s (let () (set i self.result) _s))) (let ((_s (let () (peg-source-range-begin self) (set self.result (cons (quote assign-result) (cons i (cons e (quote ()))))) (peg-source-range-end self) 1))) (and _s (let () (set e self.result) _s)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1) (let () (peg-source-range-begin self) (set self.result e) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $repetition <peg> () (let ((e)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (peg-invoke-rule $atom (quote $atom) self))) (and _s (let () (set e self.result) _s))) (let ((_list_ (group))) (and (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $query (quote $query) self) (let ((_s (let () (peg-source-range-begin self) (set self.result (cons (quote match-zero-one) (cons e (quote ())))) (peg-source-range-end self) 1))) (and _s (let () (set e self.result) _s)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $star (quote $star) self) (let ((_s (let () (peg-source-range-begin self) (set self.result (cons (quote match-zero-more) (cons e (quote ())))) (peg-source-range-end self) 1))) (and _s (let () (set e self.result) _s)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $plus (quote $plus) self) (let ((_s (let () (peg-source-range-begin self) (set self.result (cons (quote match-one-more) (cons e (quote ())))) (peg-source-range-end self) 1))) (and _s (let () (set e self.result) _s)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1) (let () (peg-source-range-begin self) (set self.result e) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $atom <peg> () (let ((p) (e)) (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $lparen (quote $lparen) self) (let ((_s (peg-invoke-rule $expression (quote $expression) self))) (and _s (let () (set e self.result) _s))) (peg-invoke-rule $rparen (quote $rparen) self) (let () (peg-source-range-begin self) (set self.result e) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $quotesgl (quote $quotesgl) self) (let ((_s (peg-invoke-rule $sexpression (quote $sexpression) self))) (and _s (let () (set e self.result) _s))) (peg-invoke-rule $space (quote $space) self) (let () (peg-source-range-begin self) (set self.result (cons (quote match-object) (cons e (quote ())))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (peg-invoke-rule $string (quote $string) self))) (and _s (let () (set e self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote match-string) (cons e (quote ())))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (peg-invoke-rule $class (quote $class) self))) (and _s (let () (set e self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote match-class) (cons e (quote ())))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (peg-invoke-rule $idpart (quote $idpart) self))) (and _s (let () (set p self.result) _s))) (set self.result (parser-stream-match-string self.source "-")) (let ((_s (peg-invoke-rule $identifier (quote $identifier) self))) (and _s (let () (set e self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote match-rule-in) (cons p (cons e (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (peg-invoke-rule $identifier (quote $identifier) self))) (and _s (let () (set e self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote match-rule) (cons e (quote ())))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $lbrace (quote $lbrace) self) (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $sexpression (quote $sexpression) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set e self.result) _s))) (peg-invoke-rule $space (quote $space) self) (peg-invoke-rule $rbrace (quote $rbrace) self) (let () (peg-source-range-begin self) (set self.result (cons (quote match-rule) e)) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $dot (quote $dot) self) (let () (peg-source-range-begin self) (set self.result (cons (quote match-any) (quote ()))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $arrow (quote $arrow) self) (let ((_s (peg-invoke-rule $sexpression (quote $sexpression) self))) (and _s (let () (set e self.result) _s))) (peg-invoke-rule $space (quote $space) self) (let () (peg-source-range-begin self) (set self.result (cons (quote result-expr) (cons e (quote ())))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $backquote (quote $backquote) self) (let ((_s (peg-invoke-rule $llist (quote $llist) self))) (and _s (let () (set e self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote match-list) (cons e (quote ())))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))))))
(define-method $llist <peg> () (let ((e)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $lparen (quote $lparen) self) (let ((_s (peg-invoke-rule $expression (quote $expression) self))) (and _s (let () (set e self.result) _s))) (peg-invoke-rule $rparen (quote $rparen) self) (let () (peg-source-range-begin self) (set self.result e) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $sexpression <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $sspace (quote $sspace) self) (peg-invoke-rule $sexpr (quote $sexpr) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $sspace <peg> () (let () (let ((_list_ (group))) (while (or (peg-invoke-rule $blank (quote $blank) self) (peg-invoke-rule $eol (quote $eol) self) (peg-invoke-rule $scomment (quote $scomment) self)) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1)))
(define-method $scomment <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source ";")) (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (not (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (peg-invoke-rule $eol (quote $eol) self) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos)))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $sexpr <peg> () (let ((f) (e) (i)) (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "-")) (let ((_s (peg-invoke-rule $sinteger (quote $sinteger) self))) (and _s (let () (set i self.result) _s))) (let () (peg-source-range-begin self) (set self.result (- i)) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (peg-invoke-rule $sinteger (quote $sinteger) self) (peg-invoke-rule $symbol (quote $symbol) self) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "?")) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "\"")) (let ((_s (and (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (not (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (set self.result (parser-stream-match-string self.source "\"")) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos)))) (peg-invoke-rule $char (quote $char) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1) (set self.result (list->string self.result))))) (and _s (let () (set e self.result) _s))) (set self.result (parser-stream-match-string self.source "\"")) (let () (peg-source-range-begin self) (set self.result e) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "(")) (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $sexpression (quote $sexpression) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set e self.result) _s))) (let ((_list_ (group))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $space (quote $space) self) (peg-invoke-rule $dot (quote $dot) self) (let ((_s (peg-invoke-rule $sexpression (quote $sexpression) self))) (and _s (let () (set f self.result) _s)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1) (peg-invoke-rule $sspace (quote $sspace) self) (set self.result (parser-stream-match-string self.source ")")) (let () (peg-source-range-begin self) (set self.result (set-list-source (concat-list e f) e)) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "[")) (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $sexpression (quote $sexpression) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set e self.result) _s))) (let ((_list_ (group))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $space (quote $space) self) (peg-invoke-rule $dot (quote $dot) self) (let ((_s (peg-invoke-rule $sexpression (quote $sexpression) self))) (and _s (let () (set f self.result) _s)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1) (peg-invoke-rule $sspace (quote $sspace) self) (set self.result (parser-stream-match-string self.source "]")) (let () (peg-source-range-begin self) (set self.result (set-list-source (cons (quote bracket) (concat-list e f)) e)) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "'")) (let ((_s (peg-invoke-rule $sexpression (quote $sexpression) self))) (and _s (let () (set e self.result) _s))) (let () (peg-source-range-begin self) (set self.result (list (quote quote) e)) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "`")) (let ((_s (peg-invoke-rule $sexpression (quote $sexpression) self))) (and _s (let () (set e self.result) _s))) (let () (peg-source-range-begin self) (set self.result (list (quote quasiquote) e)) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source ",@")) (let ((_s (peg-invoke-rule $sexpression (quote $sexpression) self))) (and _s (let () (set e self.result) _s))) (let () (peg-source-range-begin self) (set self.result (list (quote unquote-splicing) e)) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source ",")) (let ((_s (peg-invoke-rule $sexpression (quote $sexpression) self))) (and _s (let () (set e self.result) _s))) (let () (peg-source-range-begin self) (set self.result (list (quote unquote) e)) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "{")) (peg-invoke-rule $space (quote $space) self) (let ((_s (peg-invoke-rule $grammar (quote $grammar) self))) (and _s (let () (set e self.result) _s))) (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "}")) (let () (peg-source-range-begin self) (set self.result e) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (peg-source-range-begin self) (set self.result (error "error in grammar near: " (parser-stream-context self.source))) (peg-source-range-end self) 1))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source ";")) (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (not (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (set self.result (parser-stream-match-class self.source "\012\015")) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos)))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))))))
(define-method $sinteger <peg> () (let () (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "0x")) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((_list_ (group))) (while (peg-invoke-rule $higit (quote $higit) self) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set self.result (list-from-to pos (oop-at (%typecheck <parser-stream> self.source) 1))) 1))) (set self.result (string->number-base (list->string self.result) 16)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((_list_ (group))) (while (peg-invoke-rule $digit (quote $digit) self) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1))) (let () (set self.result (list-from-to pos (oop-at (%typecheck <parser-stream> self.source) 1))) 1))) (set self.result (string->number-base (list->string self.result) 10))))))
(define-method $symbol <peg> () (let () (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $symfirst (quote $symfirst) self) (let ((_list_ (group))) (while (peg-invoke-rule $symrest (quote $symrest) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result (list-from-to pos (oop-at (%typecheck <parser-stream> self.source) 1))) 1))) (set self.result (string->symbol (list->string self.result))))))
(define-method $symrest <peg> () (let () (set self.result (parser-stream-match-class self.source "!#$%&*+-./0123456789:<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ^_abcdefghijklmnopqrstuvwxyz|~"))))
(define-method $symfirst <peg> () (let () (set self.result (parser-stream-match-class self.source "!#$%&*+-/:<=>@ABCDEFGHIJKLMNOPQRSTUVWXYZ^_abcdefghijklmnopqrstuvwxyz|~"))))
(define-method $grammar <peg> () (let ((e) (d) (fields) (parent) (rules) (name)) (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (peg-invoke-rule $symbol (quote $symbol) self))) (and _s (let () (set name self.result) _s))) (peg-invoke-rule $space (quote $space) self) (peg-invoke-rule $plus (quote $plus) self) (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $definition (quote $definition) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set rules self.result) _s))) (peg-invoke-rule $space (quote $space) self) (let () (peg-source-range-begin self) (set self.result (cons (quote grammar-extend) (cons name rules))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (peg-invoke-rule $symbol (quote $symbol) self))) (and _s (let () (set name self.result) _s))) (peg-invoke-rule $space (quote $space) self) (peg-invoke-rule $colon (quote $colon) self) (let ((_s (peg-invoke-rule $symbol (quote $symbol) self))) (and _s (let () (set parent self.result) _s))) (peg-invoke-rule $space (quote $space) self) (let ((_list_ (group))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $lparen (quote $lparen) self) (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $identifier (quote $identifier) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set fields self.result) _s))) (peg-invoke-rule $rparen (quote $rparen) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1) (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $definition (quote $definition) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set rules self.result) _s))) (peg-invoke-rule $space (quote $space) self) (let () (peg-source-range-begin self) (set self.result (cons (quote grammar-define) (cons name (cons parent (cons fields rules))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (let ((_list_ (group))) (while (peg-invoke-rule $definition (quote $definition) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set d self.result) _s))) (peg-invoke-rule $space (quote $space) self) (let ((_s (let ((_list_ (group))) (and (peg-invoke-rule $expression (quote $expression) self) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1))) (and _s (let () (set e self.result) _s))) (let () (peg-source-range-begin self) (set self.result (cons (quote grammar-eval) (cons d (cons (car e) (quote ()))))) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))))))
(define-method $class <peg> () (let ((s)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "[")) (let ((_s (and (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (not (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (set self.result (parser-stream-match-string self.source "]")) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos)))) (peg-invoke-rule $char (quote $char) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1) (set self.result (list->string self.result))))) (and _s (let () (set s self.result) _s))) (set self.result (parser-stream-match-string self.source "]")) (peg-invoke-rule $space (quote $space) self) (let () (peg-source-range-begin self) (set self.result s) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $string <peg> () (let ((s)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "\"")) (let ((_s (and (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (not (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (set self.result (parser-stream-match-string self.source "\"")) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos)))) (peg-invoke-rule $char (quote $char) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1) (set self.result (list->string self.result))))) (and _s (let () (set s self.result) _s))) (set self.result (parser-stream-match-string self.source "\"")) (peg-invoke-rule $space (quote $space) self) (let () (peg-source-range-begin self) (set self.result s) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $char <peg> () (let () (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "\\")) (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "t")) (let () (peg-source-range-begin self) (set self.result 9) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "n")) (let () (peg-source-range-begin self) (set self.result 10) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "r")) (let () (peg-source-range-begin self) (set self.result 13) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "x")) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $higit (quote $higit) self) (peg-invoke-rule $higit (quote $higit) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result (list-from-to pos (oop-at (%typecheck <parser-stream> self.source) 1))) 1))) (set self.result (string->number-base (list->string self.result) 16)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "u")) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $higit (quote $higit) self) (peg-invoke-rule $higit (quote $higit) self) (peg-invoke-rule $higit (quote $higit) self) (peg-invoke-rule $higit (quote $higit) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result (list-from-to pos (oop-at (%typecheck <parser-stream> self.source) 1))) 1))) (set self.result (string->number-base (list->string self.result) 16)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1)))))
(define-method $identifier <peg> () (let ((id)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (peg-invoke-rule $idpart (quote $idpart) self))) (and _s (let () (set id self.result) _s))) (peg-invoke-rule $space (quote $space) self) (let () (peg-source-range-begin self) (set self.result id) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $idpart <peg> () (let () (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (peg-invoke-rule $letter (quote $letter) self) (let ((_list_ (group))) (while (or (peg-invoke-rule $letter (quote $letter) self) (peg-invoke-rule $digit (quote $digit) self)) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result (list-from-to pos (oop-at (%typecheck <parser-stream> self.source) 1))) 1))) (set self.result (string->symbol (list->string self.result))))))
(define-method $letter <peg> () (let () (set self.result (parser-stream-match-class self.source "ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"))))
(define-method $number <peg> () (let ((n)) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_s (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (let ((_list_ (group))) (and (set self.result (parser-stream-match-string self.source "-")) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1) (let ((_list_ (group))) (while (peg-invoke-rule $digit (quote $digit) self) (group-append _list_ self.result self.source)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1)))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let () (set self.result (list-from-to pos (oop-at (%typecheck <parser-stream> self.source) 1))) 1))) (set self.result (string->number-base (list->string self.result) 10))))) (and _s (let () (set n self.result) _s))) (peg-invoke-rule $space (quote $space) self) (let () (peg-source-range-begin self) (set self.result n) (peg-source-range-end self) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $higit <peg> () (let () (set self.result (parser-stream-match-class self.source "0123456789ABCDEFabcdef"))))
(define-method $digit <peg> () (let () (set self.result (parser-stream-match-class self.source "0123456789"))))
(define-method $dot <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source ".")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $rbrace <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "}")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $lbrace <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "{")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $rparen <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source ")")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $lparen <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "(")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $star <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "*")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $plus <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "+")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $minus <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "-")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $query <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "?")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $at <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "@")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $dollar <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "$")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $dollardbl <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "$$")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $dollarhash <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "$#")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $comma <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source ",")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $commaat <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source ",@")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $backquote <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "`")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $quotesgl <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "'")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $arrow <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "->")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $colon <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source ":")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $ampersand <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "&")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $pling <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "!")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $bar <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "|")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $space <peg> () (let () (let ((_list_ (group))) (while (or (peg-invoke-rule $blank (quote $blank) self) (peg-invoke-rule $eol (quote $eol) self) (peg-invoke-rule $comment (quote $comment) self)) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1)))
(define-method $comment <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "#")) (let ((_list_ (group))) (while (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (not (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (and (peg-invoke-rule $eol (quote $eol) self) (set-oop-at (%typecheck <parser-stream> self.source) 1 pos)))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1))) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
(define-method $eol <peg> () (let () (or (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "\012")) (let ((_list_ (group))) (while (set self.result (parser-stream-match-string self.source "\015")) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))) (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "\015")) (let ((_list_ (group))) (while (set self.result (parser-stream-match-string self.source "\012")) (group-append _list_ self.result self.source)) (set self.result (group->list! _list_)) 1)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ()))))))
(define-method $blank <peg> () (let () (set self.result (parser-stream-match-class self.source "\011 "))))
(define-method $equals <peg> () (let () (let ((pos (oop-at (%typecheck <parser-stream> self.source) 1))) (or (and (set self.result (parser-stream-match-string self.source "=")) (peg-invoke-rule $space (quote $space) self)) (let () (set-oop-at (%typecheck <parser-stream> self.source) 1 pos) ())))))
; parser bootstrap complete
; WARNING: unreachable from start: commaat
; WARNING: unreachable from start: comma
; WARNING: unreachable from start: minus
; WARNING: unreachable from start: parser_spec
